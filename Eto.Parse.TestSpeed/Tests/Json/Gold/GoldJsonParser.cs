using System;
using System.IO;

namespace Eto.Parse.TestSpeed.Tests.Json.Gold
{
	//Generated by the GOLD Parser Builder

	public class GoldJsonParser
	{
		private GOLD.Parser parser = new GOLD.Parser(); 

		private enum SymbolIndex
		{
			@Eof = 0,                                  // (EOF)
			@Error = 1,                                // (Error)
			@Whitespace = 2,                           // Whitespace
			@Comma = 3,                                // ','
			@Colon = 4,                                // ':'
			@Lbracket = 5,                             // '['
			@Rbracket = 6,                             // ']'
			@Lbrace = 7,                               // '{'
			@Rbrace = 8,                               // '}'
			@False = 9,                                // false
			@Null = 10,                                // null
			@Number = 11,                              // Number
			@String = 12,                              // String
			@True = 13,                                // true
			@Array = 14,                               // <Array>
			@Elements = 15,                            // <Elements>
			@Json = 16,                                // <Json>
			@Members = 17,                             // <Members>
			@Object = 18,                              // <Object>
			@Pair = 19,                                // <Pair>
			@Value = 20                                // <Value>
		}

		private enum ProductionIndex : short
		{
			@Json = 0,                                 // <Json> ::= <Object>
			@Json2 = 1,                                // <Json> ::= <Array>
			@Object_Lbrace_Rbrace = 2,                 // <Object> ::= '{' '}'
			@Object_Lbrace_Rbrace2 = 3,                // <Object> ::= '{' <Members> '}'
			@Members = 4,                              // <Members> ::= <Pair>
			@Members_Comma = 5,                        // <Members> ::= <Pair> ',' <Members>
			@Pair_String_Colon = 6,                    // <Pair> ::= String ':' <Value>
			@Array_Lbracket_Rbracket = 7,              // <Array> ::= '[' ']'
			@Array_Lbracket_Rbracket2 = 8,             // <Array> ::= '[' <Elements> ']'
			@Elements = 9,                             // <Elements> ::= <Value>
			@Elements_Comma = 10,                      // <Elements> ::= <Value> ',' <Elements>
			@Value_String = 11,                        // <Value> ::= String
			@Value_Number = 12,                        // <Value> ::= Number
			@Value = 13,                               // <Value> ::= <Object>
			@Value2 = 14,                              // <Value> ::= <Array>
			@Value_True = 15,                          // <Value> ::= true
			@Value_False = 16,                         // <Value> ::= false
			@Value_Null = 17                           // <Value> ::= null
		}

		public GOLD.SymbolList Expected { get; private set; }

		public object program;     //You might derive a specific object

		public GoldJsonParser()
		{
			var type = typeof(GoldJsonParser);
			parser.LoadTables(new BinaryReader(type.Assembly.GetManifestResourceStream(type.Namespace + ".JSON.egt")));
		}

		public bool Parse(string json)
		{
			using (var reader = new StringReader(json))
			{
				return Parse(reader);
			}
		}

		public bool Parse(TextReader reader)
		{
			//This procedure starts the GOLD Parser Engine and handles each of the
			//messages it returns. Each time a reduction is made, you can create new
			//custom object and reassign the .CurrentReduction property. Otherwise, 
			//the system will use the Reduction object that was returned.
			//
			//The resulting tree will be a pure representation of the language 
			//and will be ready to implement.

			GOLD.ParseMessage response; 
			bool done;                      //Controls when we leave the loop
			bool accepted = false;          //Was the parse successful?

			parser.Open(reader);
			parser.TrimReductions = false;  //Please read about this feature before enabling  

			done = false;
			while (!done)
			{
				response = parser.Parse();

				switch (response)
				{
					case GOLD.ParseMessage.LexicalError:
						//Cannot recognize token
						done = true;
						break;

					case GOLD.ParseMessage.SyntaxError:
						//Expecting a different token
						done = true;
						break;

					case GOLD.ParseMessage.Reduction:
						//Create a customized object to store the reduction

						parser.CurrentReduction = CreateNewObject(parser.CurrentReduction as GOLD.Reduction);
						break;

					case GOLD.ParseMessage.Accept:
						//Accepted!
						//program = parser.CurrentReduction   //The root node!                 
						done = true;
						accepted = true;
						break;

					case GOLD.ParseMessage.TokenRead:
						//You don't have to do anything here.
						break;

					case GOLD.ParseMessage.InternalError:
						//INTERNAL ERROR! Something is horribly wrong.
						done = true;
						break;

					case GOLD.ParseMessage.NotLoadedError:
						//This error occurs if the CGT was not loaded.                   
						done = true;
						break;

					case GOLD.ParseMessage.GroupError: 
						//GROUP ERROR! Unexpected end of file
						done = true;
						break;
				} 
			} //while

			if (!accepted)
				Expected = parser.ExpectedSymbols();
			return accepted;
		}

		private object CreateNewObject(GOLD.Reduction r)
		{ 
			object result = null;

			switch( (ProductionIndex) r.Parent.TableIndex())
			{
				case ProductionIndex.Json:                 
					// <Json> ::= <Object>
					break;

					case ProductionIndex.Json2:                 
					// <Json> ::= <Array>
					break;

					case ProductionIndex.Object_Lbrace_Rbrace:                 
					// <Object> ::= '{' '}'
					break;

					case ProductionIndex.Object_Lbrace_Rbrace2:                 
					// <Object> ::= '{' <Members> '}'
					break;

					case ProductionIndex.Members:                 
					// <Members> ::= <Pair>
					break;

					case ProductionIndex.Members_Comma:                 
					// <Members> ::= <Pair> ',' <Members>
					break;

					case ProductionIndex.Pair_String_Colon:                 
					// <Pair> ::= String ':' <Value>
					break;

					case ProductionIndex.Array_Lbracket_Rbracket:                 
					// <Array> ::= '[' ']'
					break;

					case ProductionIndex.Array_Lbracket_Rbracket2:                 
					// <Array> ::= '[' <Elements> ']'
					break;

					case ProductionIndex.Elements:                 
					// <Elements> ::= <Value>
					break;

					case ProductionIndex.Elements_Comma:                 
					// <Elements> ::= <Value> ',' <Elements>
					break;

					case ProductionIndex.Value_String:                 
					// <Value> ::= String
					break;

					case ProductionIndex.Value_Number:                 
					// <Value> ::= Number
					break;

					case ProductionIndex.Value:                 
					// <Value> ::= <Object>
					break;

					case ProductionIndex.Value2:                 
					// <Value> ::= <Array>
					break;

					case ProductionIndex.Value_True:                 
					// <Value> ::= true
					break;

					case ProductionIndex.Value_False:                 
					// <Value> ::= false
					break;

					case ProductionIndex.Value_Null:                 
					// <Value> ::= null
					break;

			}  //switch

			return result;
		}

	}; //MyParser
}

